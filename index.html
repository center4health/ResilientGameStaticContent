<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Resilient Shield Simulation Game</title>
    <link href="https://fonts.googleapis.com/css?family=Roboto:400,500,700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <style>
        /* Use Game2.html exact CSS */
        html, body { 
            height: 100%; margin: 0; padding: 0; 
            background-color: #0d1117; 
            color: #c9d1d9; 
            font-family: 'Roboto', sans-serif; 
            overflow: hidden; 
            font-size: 16px; 
        }
        *, *::before, *::after { box-sizing: border-box; }
        .container { 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            width: 100vw; 
            height: calc(100vh - 70px); 
            padding: 20px; 
        }
        .card { 
            background: #161b22; 
            box-shadow: 0 8px 24px rgba(0,0,0,0.4); 
            border: 1px solid #30363d; 
            border-radius: 8px; 
            width: 100%; 
            max-width: 1200px; 
            height: 100%; 
            padding: 0; 
            position: relative; 
            overflow: hidden; 
        }
        .media-header-area { 
            position: absolute; 
            top: 0; 
            left: 0; 
            right: 0; 
            z-index: 2; 
            padding: 25px 30px 15px 30px; 
            background: linear-gradient(to bottom, rgba(13,17,23,0.85) 0%, rgba(13,17,23,0.6) 60%, rgba(13,17,23,0.0) 100%); 
            pointer-events: none; 
        }
        .media-header-area > * { pointer-events: auto; }
        .content-overlay { 
            position: absolute; 
            bottom: 0; 
            left: 0; 
            right: 0; 
            z-index: 1; 
            background-color: rgba(22,27,34,0.9); 
            border-top: 1px solid #30363d; 
            color: #c9d1d9; 
            padding: 20px 30px; 
            max-height: 45%; 
            overflow-y: auto; 
        }
        .content-overlay::-webkit-scrollbar { width: 6px; }
        .content-overlay::-webkit-scrollbar-thumb { 
            background-color: rgba(48,54,61,0.7); 
            border-radius: 3px; 
        }
        .scene-title { 
            font-size: 1.8em; 
            font-weight: 700; 
            margin-bottom: 15px; 
            color: #f0f6fc; 
            border-bottom: 1px solid #30363d; 
            padding-bottom: 10px; 
        }
        .team-info { 
            font-size: 0.8em;  /* NEW: Reduced font size for team header */
            margin-bottom: 20px; 
            font-weight: 500; 
            color: #c9d1d9; 
            background-color: #21262d; 
            padding: 10px 15px; 
            border-radius: 6px; 
            border: 1px solid #30363d; 
        }
        .team-info strong { color: #f0f6fc; }
        .poll-area { 
            margin: 12.5px 0; 
            padding: 10px; 
            background: #21262d; 
            border: 1px solid #30363d; 
            border-radius: 6px; 
        }
        .poll-stem { 
            font-size: 1.2em; 
            margin-bottom: 15px; 
            font-weight: 600; 
            color: #f0f6fc; 
        }
        .poll-option { 
            margin: 12px 0; 
            padding: 10px; 
            border-radius: 4px; 
            transition: background-color 0.2s ease; 
        }
        .poll-option:hover { background-color: #30363d; }
        .poll-option label { 
            display: inline-block; 
            margin-left: 10px; 
            cursor: pointer; 
            color: #c9d1d9; 
            font-size: 0.95em; 
            vertical-align: middle; 
            line-height: 1.4; 
        }
        .poll-option input[type="checkbox"], 
        .poll-option input[type="radio"] { 
            vertical-align: middle; 
            cursor: pointer; 
            accent-color: #58a6ff; 
            margin-right: 5px; 
        }
        .poll-submit { 
            margin-top: 20px; 
            padding: 10px 18px; 
            font-size: 1em; 
            background-color: #238636; 
            border: 1px solid rgba(240,246,252,0.1); 
            color: #ffffff; 
            transition: background-color 0.2s ease; 
        }
        .poll-submit:hover:not(:disabled) { 
            background-color: #2ea043; 
            border-color: rgba(240,246,252,0.15); 
        }
        .poll-submit:disabled { 
            background-color: #30363d; 
            color: #8b949e; 
            cursor: not-allowed; 
            border-color: rgba(240,246,252,0.05); 
        }
        .locked-message { 
            padding: 15px 20px; 
            background: rgba(248,81,73,0.1); 
            border: 1px solid rgba(248,81,73,0.4); 
            color: #f85149; 
            border-radius: 6px; 
            margin: 20px 0; 
            text-align: center; 
            font-size: 1em; 
            font-weight: 500; 
        }
        .outcome-card { 
            background-color: #161b22; 
            border: 1px solid #30363d; 
            box-shadow: 0 4px 12px rgba(0,0,0,0.2); 
            border-radius: 6px; 
            padding: 20px; 
            margin: 25px auto; 
            width: 95%; 
            max-width: 800px; 
            text-align: center; 
        }
        .outcome-graph { 
            position: relative; 
            width: 100%; 
            height: 300px; /* NEW: set fixed height so the plot fills the space better */
            margin-bottom: 15px; 
        }
        .outcome-graph canvas { 
            display: block; 
            width: 100% !important; 
            height: 100% !important; 
        }
        .nav-buttons { 
            position: fixed; 
            bottom: 0; 
            left: 0; 
            width: 100%; 
            text-align: center; 
            background-color: #0d1117; 
            padding: 10px 0 15px 0; 
            border-top: 1px solid #30363d; 
            z-index: 10; 
        }
        button { 
            padding: 10px 18px; 
            margin: 5px 10px; 
            font-size: 1em; 
            font-weight: 500; 
            background: #21262d; 
            color: #c9d1d9; 
            border: 1px solid #30363d; 
            border-radius: 6px; 
            cursor: pointer; 
            transition: background-color 0.2s ease, border-color 0.2s ease; 
        }
        button:hover:not(:disabled) { 
            background: #30363d; 
            border-color: #8b949e; 
        }
        button:disabled { 
            background: #161b22; 
            color: #444c56; 
            border-color: #30363d; 
            cursor: not-allowed; 
        }
        .card-background-media {
            position: absolute; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            z-index: 0; 
            background-color: #000; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
        }
        .card-background-media img, .card-background-media video {
            width: 100%; 
            height: 100%; 
            object-fit: cover; 
            object-position: center center;
        }
        /* NEW: Ensure scene text appears above background */
        .scene-text {
            position: relative;
            z-index: 3;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="card" id="sceneContainer">Loading Game...</div>
    </div>
    <div class="nav-buttons">
        <button id="prevButton" onclick="prevScene()" disabled>Previous</button>
        <button id="nextButton" onclick="nextScene()">Next</button>
    </div>

    <script>
        // ========================================================================
        // == 1. CONFIGURATION & GLOBAL STATE ==
        // ========================================================================
        const AIRTABLE_CONFIG = { 
            BASE_ID: "appSv8IBMvMUGt9tW",
            SCENES_TABLE_ID: "SceneScape",
            POLLS_TABLE_ID: "Polls",
            TEAMS_TABLE_ID: "Teams", // NEW: Teams table
            CONFIG_GAME_TABLE_ID: "ConfigGame", // ADDED: ConfigGame table
            POLL_RESPONSES_TABLE_ID: "PollResponses", // ADDED: PollResponses table
            API_TOKEN: "patZuRRWmFqesY1ww.4eaa58a4dbc8358bdcbbd1036a21232e121208287476ad40247a5365d2cb096a"
        };

        let teams = [
            { name: "Region I (New England)", capacities: { testingCapacity: 3, scienceCapacity: 2, publicHealthCapacity: 8, developmentCapacity: 2 }, finances: { system: 7, personal: 4 }, socialCapital: 6 },
            { name: "Region II (NY/NJ & PR)", capacities: { testingCapacity: 4, scienceCapacity: 3, publicHealthCapacity: 7, developmentCapacity: 3 }, finances: { system: 9, personal: 5 }, socialCapital: 6 }
            // ...additional teams...
        ];
        let currentTeamIndex = 0;
        let currentTeam = teams[currentTeamIndex];

        let gameStartTime = null;
        let currentSceneIndex = 0;
        let totalScenes = 0;
        let sceneDataCache = {};
        // ADD: Ensure timelineData is defined globally
        let timelineData = { totalActs: 0 };

        let simulationState = {
            testingSuccessful: false,
            sequencingSuccessful: false,
            vaccineDeveloped: false,
            distributionSuccessful: false,
            // ...other state variables...
        };

        // ========================================================================
        // == 2. HELPER FUNCTIONS ==
        // ========================================================================
        async function fetchSceneAndChoiceData(index) {
            // Change sceneID formatting so scene 0 becomes "0000"
            const formattedID = String(index * 1000).padStart(4, '0');
            const sceneFilter = `{SceneID}='${formattedID}'`;
            const pollFilter = `{SceneID_Link}='${formattedID}'`;

            try {
                const [sceneData, pollChoicesData] = await Promise.all([
                    fetchAirtableData(AIRTABLE_CONFIG.SCENES_TABLE_ID, sceneFilter),
                    fetchAirtableData(AIRTABLE_CONFIG.POLLS_TABLE_ID, pollFilter)
                ]);

                if (!sceneData.length) throw new Error(`Scene with ID "${formattedID}" not found.`);
                sceneDataCache[index] = { sceneData: sceneData[0], pollChoicesData };
                return { sceneData: sceneData[0], pollChoicesData };
            } catch (error) {
                console.error(`Error fetching scene and poll data for SceneID "${formattedID}":`, error);
                throw error;
            }
        }

        async function fetchAirtableData(tableName, filterFormula = "") {
            const { BASE_ID, API_TOKEN } = AIRTABLE_CONFIG;
            const headers = { Authorization: `Bearer ${API_TOKEN}` };
            let url = `https://api.airtable.com/v0/${BASE_ID}/${tableName}`;
            if (filterFormula) {
                url += `?filterByFormula=${encodeURIComponent(filterFormula)}`;
            }

            try {
                const response = await fetch(url, { headers });
                if (!response.ok) throw new Error(`Failed to fetch data from ${tableName}: ${response.statusText}`);
                const data = await response.json();
                return data.records || [];
            } catch (error) {
                console.error(`Error fetching data from Airtable table "${tableName}":`, error);
                throw error;
            }
        }

        function renderMedia(sceneFields) {
            const widget = sceneFields.WidgetType ? sceneFields.WidgetType.toLowerCase() : "";
            if (widget === "video" && sceneFields.VideoURL) {
                let videoUrl = "";
                console.log("DEBUG VideoURL raw:", sceneFields.VideoURL);
                if (Array.isArray(sceneFields.VideoURL)) {
                    videoUrl = sceneFields.VideoURL[0]?.url || "";
                } else {
                    videoUrl = sceneFields.VideoURL;
                }
                console.log("DEBUG extracted videoUrl:", videoUrl);
                if (!videoUrl) return "";
                // CHANGED CODE: Remove muted and add onloadedmetadata to set volume = 1.
                return `
                    <div class="card-background-media">
                        <video autoplay loop playsinline onloadedmetadata="this.volume=1">
                            <source src="${videoUrl}" type="video/mp4">
                            Your browser does not support the video tag.
                        </video>
                    </div>`;
            } else if (widget === "image" && sceneFields.ImageURL) {
                let imageUrl = "";
                console.log("DEBUG ImageURL raw:", sceneFields.ImageURL);
                if (Array.isArray(sceneFields.ImageURL)) {
                    imageUrl = sceneFields.ImageURL[0]?.url || "";
                } else {
                    imageUrl = sceneFields.ImageURL;
                }
                console.log("DEBUG extracted imageUrl:", imageUrl);
                if (!imageUrl) return "";
                return `
                    <div class="card-background-media">
                        <img src="${imageUrl}" alt="${sceneFields.Title || 'Scene Media'}">
                    </div>`;
            } else if (widget === "graph" && sceneFields.GraphData) {
                return `
                    <div class="card-background-media">
                        <canvas id="graphCanvas"></canvas>
                    </div>`;
            }
            return "";
        }

        function updateNavButtons() {
            const prevButton = document.getElementById("prevButton");
            const nextButton = document.getElementById("nextButton");
            prevButton.disabled = currentSceneIndex === 0;
            nextButton.disabled = currentSceneIndex >= totalScenes - 1;
        }

        // ADD: New helper function "renderHeader" before its first use in renderScene
        function renderHeader(sceneFields) {
            // Assume timelineData and gameStartTime are defined globally
            const currentAct = (sceneFields.Act !== undefined) ? sceneFields.Act + 1 : 'N/A';
            const totalActs = (timelineData && timelineData.totalActs) || 'N/A';
            const elapsedTime = gameStartTime ? Math.floor((Date.now() - gameStartTime) / 60000) : 0;
            return `<div class="timeline-header">
                        <strong>Scene ${sceneFields.SceneID || 'N/A'} - Act ${currentAct}/${totalActs}</strong> | 
                        Game Time: ${sceneFields.GameDateTime || 'N/A'} | 
                        Elapsed: ${elapsedTime} min
                    </div>`;
        }

        // ADD: New function to update currentTeam from Airtable Teams table
        async function updateTeamFromAirtable() {
            if (!currentTeam || !currentTeam.name) {
                console.warn("No currentTeam name. Cannot update team from Airtable.");
                return;
            }
            const { BASE_ID, TEAMS_TABLE_ID, API_TOKEN } = AIRTABLE_CONFIG;
            const headers = { Authorization: `Bearer ${API_TOKEN}` };
            const filter = encodeURIComponent(`{Name}='${currentTeam.name}'`);
            const urlGet = `https://api.airtable.com/v0/${BASE_ID}/${TEAMS_TABLE_ID}?filterByFormula=${filter}`;
            try {
                const getResponse = await fetch(urlGet, { headers });
                const getData = await getResponse.json();
                if (getData.records && getData.records.length > 0) {
                    const latestTeam = getData.records[0].fields;
                    // Update currentTeam solely based on Airtable data.
                    currentTeam.capacities = latestTeam.capacities;
                    currentTeam.finances = latestTeam.finances;
                    currentTeam.socialCapital = latestTeam.socialCapital;
                    console.log("Updated currentTeam from Airtable:", currentTeam);
                } else {
                    console.warn("No team record found for", currentTeam.name);
                }
            } catch (error) {
                console.error("Error in updateTeamFromAirtable:", error);
            }
        }

        // UPDATED updateTeamHeader: remove duplicate extra header (renderTeamResources)
        async function updateTeamHeader() {
            await updateTeamFromAirtable();
            const headerContainer = document.querySelector('.media-header-area');
            if (headerContainer && sceneDataCache[currentSceneIndex] && sceneDataCache[currentSceneIndex].sceneData.fields) {
                // Find the team-info element and update it, leaving the header and chart intact.
                const teamInfoEl = headerContainer.querySelector('.team-info');
                if (teamInfoEl) {
                    teamInfoEl.outerHTML = renderTeamInfo();
                }
            } else {
                console.warn("updateTeamHeader: Header container or scene fields not available.");
            }
        }

        // NEW: Async helper to process dynamic placeholders of the form {From TableName, FieldName}
        async function processDynamicPlaceholders(content) {
            if (!content) return content;
            const pattern = /{From\s*([^,}]+)\s*,\s*([^}]+)}/g;
            let match;
            while ((match = pattern.exec(content)) !== null) {
                const fullMatch = match[0];
                const tableName = match[1].trim();
                const fieldName = match[2].trim();
                try {
                    const records = await fetchAirtableData(tableName);
                    let replacement = "";
                    if (records && records.length > 0) {
                        replacement = records[0].fields[fieldName] || "";
                    }
                    content = content.replace(fullMatch, replacement);
                } catch (err) {
                    console.error(`Error processing placeholder ${fullMatch}:`, err);
                    content = content.replace(fullMatch, "");
                }
            }
            return content;
        }

        // NEW: Process team-related placeholders (e.g. {NAME}, {Testing Capacity}, etc.)
        function processTeamPlaceholders(content) {
            if (!content || !currentTeam) return content;
            const mappings = {
                "NAME": currentTeam.name || "",
                "TESTING CAPACITY": currentTeam.capacities?.testingCapacity || "0",
                "SCIENCE CAPACITY": currentTeam.capacities?.scienceCapacity || "0",
                "HUMAN HEALTHCARE CAPACITY": currentTeam.capacities?.publicHealthCapacity || "0",
                "DEVELOPMENT CAPACITY": currentTeam.capacities?.developmentCapacity || "0",
                "SYSTEM FINANCES": currentTeam.finances?.system || "0",
                "SOCIAL CAPITAL": currentTeam.socialCapital || "0"
            };
            // Replace each instance of {token} (ignoring tokens starting with "FROM ")
            content = content.replace(/{\s*([^}]+)\s*}/g, (match, token) => {
                const key = token.trim().toUpperCase();
                if (key.startsWith("FROM ")) {
                    return "";
                }
                return mappings[key] !== undefined ? mappings[key] : "";
            });
            return content;
        }

        // UPDATED updatePlaceholders: first process dynamic {From Table, Field} placeholders, then team tokens.
        async function updatePlaceholders(content) {
            if (!content) return content;
            content = await processDynamicPlaceholders(content);
            content = processTeamPlaceholders(content);
            return content;
        }

        // NEW: Function to write the currentTeam record back to Airtable
        async function writeTeamToAirtable() {
            if (!currentTeam || !currentTeam.name) {
                console.warn("No currentTeam data available for update.");
                return;
            }
            const { BASE_ID, TEAMS_TABLE_ID, API_TOKEN } = AIRTABLE_CONFIG;
            const headers = {
                "Authorization": `Bearer ${API_TOKEN}`,
                "Content-Type": "application/json"
            };
            // First, fetch the record ID for the team matching currentTeam.name.
            const filter = encodeURIComponent(`{Name}='${currentTeam.name}'`);
            const urlGet = `https://api.airtable.com/v0/${BASE_ID}/${TEAMS_TABLE_ID}?filterByFormula=${filter}`;
            try {
                const getResponse = await fetch(urlGet, { headers });
                const getData = await getResponse.json();
                if (getData.records && getData.records.length > 0) {
                    const recordId = getData.records[0].id;
                    // CHANGED CODE: Correct the URL interpolation for the PATCH request.
                    const urlPatch = `https://api.airtable.com/v0/${BASE_ID}/${TEAMS_TABLE_ID}/${recordId}`;
                    const body = JSON.stringify({
                        fields: {
                            capacities: currentTeam.capacities,
                            finances: currentTeam.finances,
                            socialCapital: currentTeam.socialCapital
                        }
                    });
                    const patchResponse = await fetch(urlPatch, {
                        method: "PATCH",
                        headers,
                        body
                    });
                    if (!patchResponse.ok) {
                        console.error("Error updating team in Airtable:", patchResponse.statusText);
                    } else {
                        console.log("Team update written to Airtable successfully.");
                    }
                } else {
                    console.warn("No matching team record found in Airtable for", currentTeam.name);
                }
            } catch (error) {
                console.error("Error in writeTeamToAirtable:", error);
            }
        }

        // ADD new helper for dynamic team profile card
        async function renderTeamProfileCard() {
            const cardText = `Your team {from Teams} has been assigned to manage the response for Region {NAME}. Familiarize yourselves with your region's starting profile:
Testing Capacity: {Testing Capacity}
Science Capacity: {Science Capacity}
Human Healthcare Capacity: {Human Healthcare Capacity}
Development Capacity: {Development Capacity}
System Finances: {System Finances}M
Social Capital: {Social Capital}
These values represent relative strengths and weaknesses. Consider how these factors impact your ability to handle simultaneous human and animal health threats. Your regional profile is displayed below the timeline header.`;
            return await updatePlaceholders(cardText);
        }

        // ========================================================================
        // == 3. CORE RENDERING FUNCTIONS ==
        // ========================================================================
        async function renderScene() {
            const container = document.getElementById("sceneContainer");
            container.innerHTML = `<div style="padding: 40px; text-align: center;">Loading Scene ${currentSceneIndex}...</div>`;
            try {
                // ...existing code...
                if (!sceneDataCache[currentSceneIndex]) {
                    console.log(`Cache miss for scene ${currentSceneIndex}, fetching...`);
                    sceneDataCache[currentSceneIndex] = await fetchSceneAndChoiceData(currentSceneIndex);
                }
                const cache = sceneDataCache[currentSceneIndex];
                if (!cache || !cache.sceneData) {
                    throw new Error(`Scene data missing for scene ${currentSceneIndex}.`);
                }
                const scene = cache.sceneData.fields;
                // NEW: Use custom team profile for scene "2000" only
                const sceneID = String(scene.SceneID).trim();
                const dynamicTeamInfo = (sceneID === "2000")
                     ? await renderTeamProfileCard()
                     : renderTeamInfo();
                // Process scene title and content with placeholders
                const processedSceneTitle = await updatePlaceholders(scene.Title || "Untitled Scene");
                const processedSceneContent = await updatePlaceholders(scene.Content || "No content available.");
                
                // Render header & team info as before
                const headerHtml = renderHeader(scene);
                
                const sceneTitleHtml = `<div class="scene-title">${processedSceneTitle}</div>`;
                const sceneContentHtml = `<div class="scene-content">${processedSceneContent}</div>`;
                
                // Combine header area with timeline header, team info, and dynamic team card
                let pollHtml = "";
                let chartHtml = "";
                let sunburstHtml = "";
                // Build poll HTML only if poll choices are available
                const pollChoicesData = cache.pollChoicesData;
                if (pollChoicesData && pollChoicesData.length > 0) {
                    pollHtml = `<div class="poll-area" style="margin: 6.25px auto; max-height: 450px; overflow-y: auto; padding: 15px; box-sizing: border-box; background: #21262d; border: 1px solid #30363d; border-radius: 6px;">
                                  <div class="poll-stem">${scene.PollStem ? `<strong>${scene.PollStem}</strong>` : "<strong>Please select an option:</strong>"}</div>
                                  ${renderPollOptions(pollChoicesData)}
                                  <button type="button" class="poll-submit" onclick="submitPoll(event)">Submit Response</button>
                                </div>`;
                }
                // Build chart HTML if widget type is Chart
                if ((scene.WidgetType || "").toLowerCase() === "chart") {
                    chartHtml = `<div class="outcome-card" style="margin: 6.25px auto; max-height: 450px; overflow-y: auto; padding: 15px; box-sizing: border-box;">
                                  <div class="outcome-graph">
                                    <canvas id="chartCanvas0"></canvas>
                                  </div>
                                </div>`;
                }
                // Check if the chart type is "sunburst"
                if ((scene.WidgetType || "").toLowerCase() === "sunburst") {
                    sunburstHtml = `<div class="sunburst-chart" style="margin: 20px auto; max-height: 450px; overflow-y: auto; padding: 15px; box-sizing: border-box; background: #21262d; border: 1px solid #30363d; border-radius: 6px;">
                                        <div id="sunburstChart" style="width: 100%; height: 400px;"></div>
                                    </div>`;
                    // Fetch and render the sunburst chart
                    setTimeout(() => renderSunburstChart(), 500);
                }
                container.innerHTML = `
                    ${renderMedia(scene)}
                    <div class="media-header-area" style="padding-bottom: 10px;">
                        ${headerHtml}
                    </div>
                    <div class="main-visual-area" style="display: flex; justify-content: center; align-items: center; height: auto; margin: 100px auto 10px auto; padding-bottom: 10px;">
                        ${chartHtml || pollHtml}
                    </div>
                    <div class="content-overlay" style="padding-top: 10px;">
                        <div class="scene-title">${processedSceneTitle}</div>
                        <div class="scene-content">${processedSceneContent}</div>
                        ${sunburstHtml}
                    </div>
                `;
                // Render chart after inserting HTML
                if ((scene.WidgetType || "").toLowerCase() === "chart") {
                    const chartData = generatePlaceholderChartData(cache.sceneData);
                    renderChart(cache.sceneData, 0, chartData);
                }
                // ...existing code to update nav buttons and timers...
                updateNavButtons();
                if (scene.TimerSeconds && scene.TimerSeconds > 0) {
                    initializeTimer(scene.TimerSeconds);
                }
                await updateTeamHeader();
            } catch (error) {
                container.innerHTML = `<p style="color:red;">Error loading scene ${currentSceneIndex}: ${error.message}</p>`;
            }
        }

        async function submitPoll(event) {
            if (event) event.preventDefault();
            clearInterval(countdownInterval);

            const form = document.getElementById("pollForm");
            const submitButton = document.querySelector('.poll-submit');
            if (submitButton) {
                submitButton.disabled = true;
                submitButton.innerText = "Processing...";
            }

            let selectedChoiceIDs = [];
            if (form && form.elements["pollChoice"]) {
                const choices = form.elements["pollChoice"];
                if (choices.type === 'radio') {
                    const checkedRadio = Array.from(choices).find(radio => radio.checked);
                    if (checkedRadio) selectedChoiceIDs.push(checkedRadio.value);
                } else if (choices.length !== undefined) {
                    for (let i = 0; i < choices.length; i++) {
                        if (choices[i].checked) selectedChoiceIDs.push(choices[i].value);
                    }
                }
            } else {
                console.error("No poll options found.");
                if (submitButton) submitButton.innerText = "Submit Response";
                return;
            }

            console.log("Selected choice ID(s):", selectedChoiceIDs);

            const currentSceneFullData = sceneDataCache[currentSceneIndex];
            if (!currentSceneFullData || !currentSceneFullData.pollChoicesData) {
                console.error("Cannot process poll: Missing cached scene/poll data.");
                if (submitButton) submitButton.innerText = "Error";
                return;
            }

            // Create a lookup for poll choices.
            const choiceDataLookup = {};
            currentSceneFullData.pollChoicesData.forEach(choice => {
                choiceDataLookup[choice.id] = choice;
            });

            try {
                // Process each selected poll choice.
                for (const choiceID of selectedChoiceIDs) {
                    const choiceData = choiceDataLookup[choiceID];
                    if (!choiceData) {
                        console.error("Invalid choice ID submitted:", choiceID);
                        console.error("An invalid choice was selected. Please try again.");
                        return;
                    }
                    // Evaluate condition before submission.
                    if (!evaluateCondition(choiceData.fields.ConditionLogic)) {
                        console.error(`The selected option "${choiceData.fields.ChoiceText}" is no longer valid.`);
                        return;
                    }
                    await processPollSubmission(choiceData, currentSceneFullData.sceneData.fields.PollID);
                }
                if (submitButton) {
                    submitButton.innerText = "Response Submitted";
                }
                console.log("Poll submission complete.");
                // ...existing code (no alert on success)...
            } catch (error) {
                console.error("Error during poll submission:", error);
                if (submitButton) {
                    submitButton.innerText = "Error";
                }
                // ...existing code (no alert on failure)...
            }
        }

        // New helper function to process individual poll submissions based on target table.
        async function processPollSubmission(choiceRecord, pollID) {
            const modelParameter = choiceRecord.fields.ModelParameter;
            const operator = choiceRecord.fields.Operator; // e.g. "+" or "-" (if provided)
            if (modelParameter) {
                const parts = modelParameter.split(".");
                if (parts.length >= 2) {
                    const tableName = parts[0].trim().toLowerCase();
                    const fieldName = parts.slice(1).join(".").trim();
                    if (tableName === "teams") {
                        // Mapping for Teams fields update
                        const teamFieldMapping = {
                            "System Finance": { container: "finances", key: "system" },
                            "Social Capital": { container: "socialCapital" },
                            "Human Healthcare Capacity": { container: "capacities", key: "publicHealthCapacity" },
                            "Testing Capacity": { container: "capacities", key: "testingCapacity" },
                            "Science Capacity": { container: "capacities", key: "scienceCapacity" },
                            "Animal Surveillance Capacity": { container: "capacities", key: "animalSurveillanceCapacity" }
                        };
                        const mapping = teamFieldMapping[fieldName];
                        if (mapping) {
                            let inc = parseInt(choiceRecord.fields.UpdateIncrement || "1", 10);
                            if (operator && operator.trim() === "-") {
                                inc = -inc;
                            }
                            if (mapping.container === "finances") {
                                currentTeam.finances[mapping.key] = (parseInt(currentTeam.finances[mapping.key] || "0", 10) + inc);
                            } else if (mapping.container === "capacities") {
                                currentTeam.capacities[mapping.key] = (parseInt(currentTeam.capacities[mapping.key] || "0", 10) + inc);
                            } else if (mapping.container === "socialCapital") {
                                currentTeam.socialCapital = (parseInt(currentTeam.socialCapital || "0", 10) + inc);
                            }
                            await writeTeamToAirtable();
                        } else {
                            console.error("Mapping not found for field:", fieldName);
                        }
                    } else if (tableName === "configgame") {
                        let inc = parseInt(choiceRecord.fields.UpdateIncrement || "1", 10);
                        if (operator && operator.trim() === "-") {
                            inc = -inc;
                        }
                        await writeToGameConfig(fieldName, inc);
                    } else {
                        await updatePollResponses([choiceRecord.id], pollID);
                    }
                } else {
                    await updatePollResponses([choiceRecord.id], pollID);
                }
            } else {
                await updatePollResponses([choiceRecord.id], pollID);
            }
        }

        // NEW: Helper to update GameConfig table
        async function writeToGameConfig(fieldName, increment) {
            const { BASE_ID, API_TOKEN } = AIRTABLE_CONFIG;
            const tableName = "ConfigGame";
            const headers = {
                Authorization: `Bearer ${API_TOKEN}`,
                "Content-Type": "application/json"
            };
            try {
                // Find GameConfig record for the current team using a filter on the 'Team' field
                const filter = encodeURIComponent(`{Team}='${currentTeam.name}'`);
                const urlGet = `https://api.airtable.com/v0/${BASE_ID}/${tableName}?filterByFormula=${filter}`;
                const response = await fetch(urlGet, { headers });
                const data = await response.json();
                if (data.records && data.records.length > 0) {
                    const recordId = data.records[0].id;
                    const currentVal = parseInt(data.records[0].fields[fieldName] || "0", 10);
                    const newVal = currentVal + increment;
                    const body = JSON.stringify({
                        fields: { [fieldName]: newVal }
                    });
                    const urlPatch = `https://api.airtable.com/v0/${BASE_ID}/${tableName}/${recordId}`;
                    const patchResponse = await fetch(urlPatch, { method: "PATCH", headers, body });
                    if (!patchResponse.ok) {
                        console.error("Error updating GameConfig for", fieldName, patchResponse.statusText);
                    } else {
                        console.log("GameConfig updated successfully for", fieldName, newVal);
                    }
                } else {
                    console.warn("No GameConfig record found for team", currentTeam.name);
                }
            } catch (error) {
                console.error("Error in writeToGameConfig:", error);
            }
        }

        async function updatePollResponses(selectedChoiceIDs, pollID) {
            const { BASE_ID, API_TOKEN } = AIRTABLE_CONFIG;
            const headers = {
                Authorization: `Bearer ${API_TOKEN}`,
                "Content-Type": "application/json"
            };
            // CHANGED CODE: Build payload and check response with json parsing.
            const payload = {
                records: selectedChoiceIDs.map(choiceId => ({
                    fields: {
                        PollID: pollID,       // Ensure these field names match Airtable
                        ChoiceID: choiceId,
                        TeamID: currentTeam.name,
                        ResponseCount: 1
                    }
                }))
            };
            console.log("Sending PollResponses payload:", JSON.stringify(payload));
            const url = `https://api.airtable.com/v0/${BASE_ID}/PollResponses`;
            const response = await fetch(url, { method: "POST", headers, body: JSON.stringify(payload) });
            if (!response.ok) {
                const text = await response.text();
                console.error("Error updating PollResponses:", text);
                throw new Error(`Failed to update PollResponses: ${response.statusText}`);
            }
            const data = await response.json();
            console.log("PollResponses updated successfully:", data);
        }

        async function writeToAirtable(tableName, parameter, value) {
            const { BASE_ID, API_TOKEN } = AIRTABLE_CONFIG;
            const headers = {
                Authorization: `Bearer ${API_TOKEN}`,
                "Content-Type": "application/json"
            };

            const record = {
                fields: {
                    Parameter: parameter,
                    Value: value,
                    TeamID: currentTeam.name
                }
            };
            console.log(`Writing to ${tableName} with payload:`, JSON.stringify({ records: [record] }));
            const url = `https://api.airtable.com/v0/${BASE_ID}/${tableName}`;
            try {
                const response = await fetch(url, {
                    method: "POST",
                    headers,
                    body: JSON.stringify({ records: [record] })
                });
                const text = await response.text();
                console.log(`Raw response from ${tableName} POST:`, text);
                if (!response.ok) {
                    console.error(`Error writing to ${tableName}:`, text);
                    throw new Error(`Failed to write to ${tableName}: ${response.status} ${response.statusText}`);
                }
                console.log(`Successfully wrote to ${tableName}:`, parameter, value);
            } catch (error) {
                console.error(`Error writing to ${tableName}:`, error);
                throw error;
            }
        }

        async function nextScene() {
            if (currentSceneIndex < totalScenes - 1) {
                currentSceneIndex++;
                await renderScene();
            }
        }

        async function prevScene() {
            if (currentSceneIndex > 0) {
                currentSceneIndex--;
                await renderScene();
            }
        }

        // ========================================================================
        // == 4. INITIALIZATION ==
        // ========================================================================
        async function fetchInitialSceneList() {
            const { BASE_ID, SCENES_TABLE_ID, API_TOKEN } = AIRTABLE_CONFIG;
            const headers = { Authorization: `Bearer ${API_TOKEN}` };
            const url = `https://api.airtable.com/v0/${BASE_ID}/${SCENES_TABLE_ID}?sort%5B0%5D%5Bfield%5D=SceneID&sort%5B0%5D%5Bdirection%5D=asc`;
            try {
                const response = await fetch(url, { headers });
                // Fix: use "response" instead of "getResponse"
                const data = await response.json();
                // ...existing code...
                if (!data.records || data.records.length === 0) {
                    totalScenes = 1;
                    return;
                }
                totalScenes = data.records.length;
            } catch (error) {
                console.error("Error fetching scene list:", error);
                throw error;
            }
        }

        async function initializeGame() {
            console.log("Initializing Game...");
            try {
                await fetchInitialSceneList();
            } catch (err) {
                console.error("Scene list error. Using default totalScenes.");
                totalScenes = 40;
            }
            await renderScene();
        }

        document.addEventListener("DOMContentLoaded", initializeGame);

        // ADD: Missing initializeTimer function
        function initializeTimer(durationSeconds) {
            const container = document.getElementById("sceneContainer");
            if (!container) {
                console.error("Scene container not found!");
                return;
            }
            // Create or update the timer element
            let timerEl = document.getElementById("timerDisplay");
            if (!timerEl) {
                timerEl = document.createElement("div");
                timerEl.id = "timerDisplay";
                timerEl.style.position = "absolute";
                timerEl.style.top = "10px";
                timerEl.style.right = "10px";
                timerEl.style.backgroundColor = "#161b22";
                timerEl.style.color = "#f0f6fc";
                timerEl.style.padding = "10px 15px";
                timerEl.style.border = "1px solid #30363d";
                timerEl.style.borderRadius = "6px";
                timerEl.style.fontSize = "1em";
                timerEl.style.fontWeight = "500";
                container.appendChild(timerEl);
            }
            clearInterval(window.countdownInterval);
            let timeLeft = durationSeconds;
            updateTimerDisplay(timerEl, timeLeft);
            window.countdownInterval = setInterval(() => {
                timeLeft--;
                if (timeLeft >= 0) {
                    updateTimerDisplay(timerEl, timeLeft);
                } else {
                    clearInterval(window.countdownInterval);
                    alert("Time's up! Submitting current selection (if any).");
                    submitPoll();
                }
            }, 1000);
        }
        
        // ADD: Helper to update timer display
        function updateTimerDisplay(timerEl, timeLeft) {
            const minutes = Math.floor(timeLeft / 60);
            const seconds = (timeLeft % 60).toString().padStart(2, "0");
            timerEl.innerText = `Time remaining: ${minutes}:${seconds}`;
        }

        function renderTeamInfo() { 
            console.log("renderTeamInfo called. CurrentTeam:", JSON.stringify(currentTeam)); 
            if (!currentTeam) return '<div class="team-info">Error loading team data</div>'; 
            const caps = currentTeam.capacities || {}; 
            const fins = currentTeam.finances || {}; 
            const socialCap = currentTeam.socialCapital !== undefined ? currentTeam.socialCapital : 'N/A'; 
            // Updated to display actual capacity values
            return `<div class="team-info">
                <strong>Team:</strong> ${currentTeam.name || 'N/A'} | 
                <strong>Testing Capacity:</strong> ${caps.testingCapacity || 0} | 
                <strong>Science Capacity:</strong> ${caps.scienceCapacity || 0} | 
                <strong>Public Health Capacity:</strong> ${caps.publicHealthCapacity || 0} | 
                <strong>Development Capacity:</strong> ${caps.developmentCapacity || 0} | 
                <strong>System Finances:</strong> ${fins.system || 0}M | 
                <strong>Social Capital:</strong> ${socialCap}
            </div>`;
        }

        // Updated renderTeamResources function to dynamically insert region name and parameter values:
        function renderTeamResources() {
            if (!currentTeam) return "<p>Team data not available.</p>";
            const caps = currentTeam.capacities || {};
            const fins = currentTeam.finances || {};
            const social = currentTeam.socialCapital ?? "N/A";
            return `
                <div class="team-info">
                    Your team has been assigned to manage the response for <strong>Region ${currentTeam.name}</strong>.
                    Familiarize yourselves with your region's starting profile:
                    <ul>
                        <li>Testing Capacity: ${caps.testingCapacity || 0}</li>
                        <li>Science Capacity: ${caps.scienceCapacity || 0}</li>
                        <li>Human Healthcare Capacity: ${caps.publicHealthCapacity || 0}</li>
                        <li>Development Capacity: ${caps.developmentCapacity || 0}</li>
                        <li>System Finances: ${fins.system || 0}M</li>
                        <li>Social Capital: ${social}</li>
                    </ul>
                </div>
            `;
        }

        // Add missing generatePlaceholderChartData() helper:
        function generatePlaceholderChartData(sceneData) {
            if (!sceneData || !sceneData.fields) {
                return null;
            }
            const scene = sceneData.fields;
            let chartType = (scene.ChartType || "bar").toLowerCase();
            let chartData;
            if (chartType === "line") {
                chartData = {
                    labels: ["Start", "Act 1", "Act 2", "Act 3", "Now"],
                    datasets: [{
                        label: scene.Title || "Line Chart",
                        data: [10, 20, 30, 40, 50],
                        borderColor: "#58a6ff",
                        fill: false
                    }]
                };
            } else if (chartType === "pie") {
                chartData = {
                    labels: ["A", "B", "C", "D"],
                    datasets: [{
                        data: [25, 25, 25, 25],
                        backgroundColor: ["#2ea043", "#58a6ff", "#db617e", "#a371f7"]
                    }]
                };
            } else {
                chartData = {
                    labels: ["X", "Y", "Z"],
                    datasets: [{
                        label: scene.Title || "Bar Chart",
                        data: [5, 15, 10],
                        backgroundColor: "#58a6ff"
                    }]
                };
            }
            return { type: chartType, data: chartData, title: scene.Title || "Chart" };
        }

        function renderChart(sceneData, canvasIndex, chartDataSource = null) {
            const canvasId = `chartCanvas${canvasIndex}`;
            const canvasElement = document.getElementById(canvasId);
            if (!canvasElement) {
                console.error(`Canvas element ${canvasId} not found.`);
                return;
            }
            const ctx = canvasElement.getContext("2d");
            let chartInfo = chartDataSource;
            if (!chartInfo) {
                console.warn("No chart data source, generating placeholder for scene:", sceneData?.fields?.SceneID);
                chartInfo = generatePlaceholderChartData(sceneData);
            }
            if (!chartInfo || !chartInfo.data) {
                console.error("No valid chart data for scene:", sceneData?.fields?.SceneID);
                canvasElement.parentElement.innerHTML = "<p style='color: orange;'>Chart data not available.</p>";
                return;
            }
            const chartType = chartInfo.type || "bar";
            const chartData = chartInfo.data;
            const options = {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: true,
                        labels: { color: "#c9d1d9" }
                    },
                    title: {
                        display: true,
                        text: chartInfo.title || "Chart",
                        color: "#f0f6fc",
                        font: { size: 16 }
                    }
                },
                scales: {
                    x: {
                        ticks: { color: "#8b949e" },
                        grid: { color: "#30363d" }
                    },
                    y: {
                        ticks: { color: "#8b949e" },
                        grid: { color: "#30363d" }
                    }
                }
            };
            if (chartType === "pie") {
                delete options.scales;
            }
            if (canvasIndex === 0 && window.currentChart) {
                window.currentChart.destroy();
            }
            const newChart = new Chart(ctx, { type: chartType, data: chartData, options: options });
            if (canvasIndex === 0) {
                window.currentChart = newChart;
            }
        }

        async function renderSunburstChart() {
            const { BASE_ID, TEAMS_TABLE_ID, API_TOKEN } = AIRTABLE_CONFIG;
            const headers = { Authorization: `Bearer ${API_TOKEN}` };
            const url = `https://api.airtable.com/v0/${BASE_ID}/${TEAMS_TABLE_ID}`;
        
            try {
                const response = await fetch(url, { headers });
                if (!response.ok) throw new Error(`Failed to fetch Teams data: ${response.statusText}`);
                const data = await response.json();
        
                // Process data for the sunburst chart
                const labels = [];
                const parents = [];
                const values = [];
        
                data.records.forEach(record => {
                    const fields = record.fields;
                    labels.push(fields.Name || "Unknown");
                    parents.push(""); // Root level
                    values.push(fields.Capacities?.testingCapacity || 0); // Example: testingCapacity
                });
        
                const chartData = [{
                    type: "sunburst",
                    labels: labels,
                    parents: parents,
                    values: values,
                    branchvalues: "total",
                    textinfo: "label+value+percent entry"
                }];
        
                const layout = {
                    margin: { t: 10, l: 10, r: 10, b: 10 },
                    paper_bgcolor: "#161b22",
                    font: { color: "#c9d1d9" }
                };
        
                Plotly.newPlot("sunburstChart", chartData, layout);
            } catch (error) {
                console.error("Error rendering sunburst chart:", error);
                document.getElementById("sunburstChart").innerHTML = `<p style="color: red;">Error loading chart data.</p>`;
            }
        }

        function evaluateCondition(conditionLogic) {
            if (!conditionLogic || typeof conditionLogic !== "string") return true;

            try {
                // Dynamically evaluate the condition using the current simulation state
                const conditionFunction = new Function(
                    "simulationState",
                    `return (${conditionLogic});`
                );
                return conditionFunction(simulationState);
            } catch (error) {
                console.error(`Error evaluating condition "${conditionLogic}":`, error);
                return false;
            }
        }

        function renderPollOptions(pollChoicesData) {
            const pollHtml = pollChoicesData
                .filter(choice => evaluateCondition(choice.fields.ConditionLogic)) // Only include visible choices
                .map((choice, idx) => {
                    const choiceText = choice.fields.ChoiceText || "Choice text missing";
                    return `
                        <div class="poll-option">
                            <input type="radio" id="choice${idx}" name="pollChoice" value="${choice.id}">
                            <label for="choice${idx}">${choiceText}</label>
                        </div>`;
                })
                .join("");

            return `<form id="pollForm">${pollHtml}</form>`;
        }
    </script>
</body>
</html>
