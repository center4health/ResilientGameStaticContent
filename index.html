<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Resilient Shield Simulation Game</title>
    <link href="https://fonts.googleapis.com/css?family=Roboto:400,500,700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <style>
        /* Use Game2.html exact CSS */
        html, body { 
            height: 100%; margin: 0; padding: 0; 
            background-color: #0d1117; 
            color: #c9d1d9; 
            font-family: 'Roboto', sans-serif; 
            overflow: hidden; 
            font-size: 16px; 
        }
        *, *::before, *::after { box-sizing: border-box; }
        .container { 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            width: 100vw; 
            height: calc(100vh - 70px); 
            padding: 20px; 
        }
        .card { 
            background: #161b22; 
            box-shadow: 0 8px 24px rgba(0,0,0,0.4); 
            border: 1px solid #30363d; 
            border-radius: 8px; 
            width: 100%; 
            max-width: 1200px; 
            height: 100%; 
            padding: 0; 
            position: relative; 
            overflow: hidden; 
        }
        .media-header-area { 
            position: absolute; 
            top: 0; 
            left: 0; 
            right: 0; 
            z-index: 2; 
            padding: 25px 30px 15px 30px; 
            background: linear-gradient(to bottom, rgba(13,17,23,0.85) 0%, rgba(13,17,23,0.6) 60%, rgba(13,17,23,0.0) 100%); 
            pointer-events: none; 
        }
        .media-header-area > * { pointer-events: auto; }
        .content-overlay { 
            position: absolute; 
            bottom: 70px; /* CHANGED: Stop the overlay above the fixed nav-buttons */
            left: 0; 
            right: 0; 
            z-index: 1; 
            background-color: rgba(22,27,34,0.9); 
            border-top: 1px solid #30363d; 
            color: #c9d1d9; 
            padding: 20px 30px; 
            max-height: 45%; 
            overflow-y: auto; 
            padding-bottom: 70px; /* ADDED: Ensure content stops above bottom nav-buttons */
        }
        .content-overlay::-webkit-scrollbar { width: 6px; }
        .content-overlay::-webkit-scrollbar-thumb { 
            background-color: rgba(48,54,61,0.7); 
            border-radius: 3px; 
        }
        .scene-title { 
            font-size: 1.8em; 
            font-weight: 700; 
            margin-bottom: 15px; 
            color: #f0f6fc; 
            border-bottom: 1px solid #30363d; 
            padding-bottom: 10px; 
        }
        .team-info { 
            font-size: 0.8em;  /* NEW: Reduced font size for team header */
            margin-bottom: 20px; 
            font-weight: 500; 
            color: #c9d1d9; 
            background-color: #21262d; 
            padding: 10px 15px; 
            border-radius: 6px; 
            border: 1px solid #30363d; 
        }
        .team-info strong { color: #f0f6fc; }
        .poll-area { 
            margin: 12.5px 0; 
            padding: 10px; 
            background: #21262d; 
            border: 1px solid #30363d; 
            border-radius: 6px; 
        }
        .poll-stem { 
            font-size: 1.2em; 
            margin-bottom: 15px; 
            font-weight: 600; 
            color: #f0f6fc; 
        }
        .poll-option { 
            margin: 12px 0; 
            padding: 10px; 
            border-radius: 4px; 
            transition: background-color 0.2s ease; 
        }
        .poll-option:hover { background-color: #30363d; }
        .poll-option label { 
            display: inline-block; 
            margin-left: 10px; 
            cursor: pointer; 
            color: #c9d1d9; 
            font-size: 0.95em; 
            vertical-align: middle; 
            line-height: 1.4; 
        }
        .poll-option input[type="checkbox"], 
        .poll-option input[type="radio"] { 
            vertical-align: middle; 
            cursor: pointer; 
            accent-color: #58a6ff; 
            margin-right: 5px; 
        }
        .poll-submit { 
            margin-top: 20px; 
            padding: 10px 18px; 
            font-size: 1em; 
            background-color: #238636; 
            border: 1px solid rgba(240,246,252,0.1); 
            color: #ffffff; 
            transition: background-color 0.2s ease; 
        }
        .poll-submit:hover:not(:disabled) { 
            background-color: #2ea043; 
            border-color: rgba(240,246,252,0.15); 
        }
        .poll-submit:disabled { 
            background-color: #30363d; 
            color: #8b949e; 
            cursor: not-allowed; 
            border-color: rgba(240,246,252,0.05); 
        }
        .locked-message { 
            padding: 15px 20px; 
            background: rgba(248,81,73,0.1); 
            border: 1px solid rgba(248,81,73,0.4); 
            color: #f85149; 
            border-radius: 6px; 
            margin: 20px 0; 
            text-align: center; 
            font-size: 1em; 
            font-weight: 500; 
        }
        .outcome-card { 
            background-color: #161b22; 
            border: 1px solid #30363d; 
            box-shadow: 0 4px 12px rgba(0,0,0,0.2); 
            border-radius: 6px; 
            padding: 20px; 
            margin: 25px auto; 
            width: 95%; 
            max-width: 800px; 
            text-align: center; 
        }
        .outcome-graph { 
            position: relative; 
            width: 100%; 
            height: 300px; /* NEW: set fixed height so the plot fills the space better */
            margin-bottom: 15px; 
        }
        .outcome-graph canvas { 
            display: block; 
            width: 100% !important; 
            height: 100% !important; 
        }
        .nav-buttons { 
            position: fixed; 
            bottom: 0; 
            left: 0; 
            width: 100%; 
            text-align: center; 
            background-color: #0d1117; 
            padding: 10px 0 15px 0; 
            border-top: 1px solid #30363d; 
            z-index: 10; 
        }
        button { 
            padding: 10px 18px; 
            margin: 5px 10px; 
            font-size: 1em; 
            font-weight: 500; 
            background: #21262d; 
            color: #c9d1d9; 
            border: 1px solid #30363d; 
            border-radius: 6px; 
            cursor: pointer; 
            transition: background-color 0.2s ease, border-color 0.2s ease; 
        }
        button:hover:not(:disabled) { 
            background: #30363d; 
            border-color: #8b949e; 
        }
        button:disabled { 
            background: #161b22; 
            color: #444c56; 
            border-color: #30363d; 
            cursor: not-allowed; 
        }
        .card-background-media {
            position: absolute; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            z-index: 0; 
            background-color: #000; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
        }
        .card-background-media img, .card-background-media video {
            width: 100%; 
            height: 100%; 
            object-fit: cover; 
            object-position: center center;
        }
        /* NEW: Ensure scene text appears above background */
        .scene-text {
            position: relative;
            z-index: 3;
        }
        /* NEW: Interactive overlay for polls/plots */
        .interactive-overlay {
            position: absolute;
            top: 40px; /* reduced from 80px */
            height: calc(100% - 160px); /* adjusted reserved space: 40px (top) + 120px (narrative) */
            left: 0;
            right: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            margin-bottom: 10px; /* added margin to separate from lower section */
        }
        .card-dynamic {
            height: 90%;  /* 90% of the interactive overlay's height */
            width: 90%;
            background: #21262d;
            border: 1px solid #30363d;
            border-radius: 6px;
            overflow-y: auto;
            padding: 0; /* removed extra padding */
            box-sizing: border-box;
        }
        /* NEW: Narrative overlay for scene title and content */
        .narrative-overlay {
            position: absolute;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 2;
            background-color: rgba(22,27,34,0.9);
            padding: 20px 30px;
            overflow-y: auto;
            max-height: 40%;
            margin-top: 10px; /* added top margin for spacing */
        }
        .timeline-header {
            font-size: 0.7em; /* NEW: 30% smaller text for scene info and timing */
        }
        /* Add new poll card styles */
        .poll-card {
            border: 1px solid #30363d;
            border-radius: 6px;
            padding: 10px;
            margin-bottom: 10px;
            cursor: pointer;
        }
        .poll-card.selected {
            background-color: #2ea043;
        }
        .poll-text {
            font-size: 1em;
            margin-bottom: 5px;
        }
        .poll-details {
            font-size: 0.8em;
            color: #8b949e;
            display: flex;
            justify-content: space-between;
        }
        .poll-detail {
            margin-right: 5px;
        }
        @media screen and (max-width: 600px) {
            .interactive-overlay {
                height: calc(100% - 220px); /* Increase reserved space for narrative overlay */
            }
            .narrative-overlay {
                max-height: 180px; /* Fixed maximum height to ensure spacing */
                padding: 15px 20px; /* Adjust padding if necessary */
            }
        }
        .poll-category-nav {
            display: flex;
            gap: 18px;
            margin-bottom: 18px;
            border-bottom: 1px solid #30363d;
            padding-bottom: 6px;
            overflow-x: auto;
        }
        .poll-category-tab {
            cursor: pointer;
            font-weight: 500;
            color: #8b949e;
            padding: 4px 10px;
            border-bottom: 2px solid transparent;
            transition: color 0.2s, border-bottom 0.2s;
            white-space: nowrap;
        }
        .poll-category-tab.selected {
            color: #f0f6fc;
            border-bottom: 2px solid #2ea043;
        }
        .poll-cards-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 14px;
        }
        @media (max-width: 700px) {
            .poll-cards-grid {
                grid-template-columns: 1fr;
            }
        }
        .poll-no-choices {
            color: #8b949e;
            padding: 20px 0;
            text-align: center;
        }
        .poll-search-bar-container {
            margin-bottom: 12px;
            display: flex;
            justify-content: flex-end;
        }
        .poll-search-bar {
            padding: 7px 12px;
            border-radius: 4px;
            border: 1px solid #30363d;
            background: #161b22;
            color: #c9d1d9;
            font-size: 1em;
            width: 260px;
            max-width: 100%;
        }
        .poll-search-bar:focus {
            outline: 2px solid #2ea043;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="card" id="sceneContainer">Loading Game...</div>
    </div>
    <div class="nav-buttons">
        <button id="prevButton" onclick="prevScene()" disabled>Previous</button>
        <button id="nextButton" onclick="nextScene()">Next</button>
    </div>

    <script>
        // ========================================================================
        // == 1. CONFIGURATION & GLOBAL STATE ==
        // ========================================================================
        const AIRTABLE_CONFIG = { 
            BASE_ID: "appSv8IBMvMUGt9tW",
            SCENES_TABLE_ID: "SceneScape",
            POLLS_TABLE_ID: "Polls",
            TEAMS_TABLE_ID: "Teams", // NEW: Teams table
            CONFIG_GAME_TABLE_ID: "ConfigGame", // ADDED: ConfigGame table
            POLL_RESPONSES_TABLE_ID: "PollResponses", // ADDED: PollResponses table
            API_TOKEN: "patZuRRWmFqesY1ww.4eaa58a4dbc8358bdcbbd1036a21232e121208287476ad40247a5365d2cb096a"
        };

        let teams = [
            { name: "Region I (New England)", capacities: { testingCapacity: 3, scienceCapacity: 2, publicHealthCapacity: 8, developmentCapacity: 2 }, finances: { system: 7, personal: 4 }, socialCapital: 6 },
            { name: "Region II (NY/NJ & PR)", capacities: { testingCapacity: 4, scienceCapacity: 3, publicHealthCapacity: 7, developmentCapacity: 3 }, finances: { system: 9, personal: 5 }, socialCapital: 6 }
            // ...additional teams...
        ];
        let currentTeamIndex = 0;
        let currentTeam = teams[currentTeamIndex];

        let gameStartTime = null;
        let sceneList = [];
        let currentSceneIndex = 0;
        let totalScenes = 0;
        let sceneDataCache = {};
        // ADD: Ensure timelineData is defined globally
        let timelineData = { totalActs: 0 };

        let simulationState = {
            testingSuccessful: false,
            sequencingSuccessful: false,
            vaccineDeveloped: false,
            distributionSuccessful: false,
            // ...other state variables...
        };

        // Add a global flag to prevent duplicate submissions
        let pollSubmitted = false;

        // Add global for selected action poll category
        let selectedActionCategory = null;

        // Add global for search
        let actionPollSearchTerm = "";

        // ========================================================================
        // == 2. HELPER FUNCTIONS ==
        // ========================================================================
        // Replace fetchSceneAndChoiceData to fetch *all* action poll choices for action polls
        async function fetchSceneAndChoiceData(index) {
            if (!sceneList[index]) throw new Error(`No scene at index ${index}`);
            const sceneID = sceneList[index].fields.SceneID;
            const sceneFilter = `{SceneID}='${sceneID}'`;
            const pollFilter = `{SceneID_Link}='${sceneID}'`;

            // Fetch scene data and all action poll choices (not just those mapped to this scene)
            try {
                const [sceneData, pollChoicesData, allActionChoices] = await Promise.all([
                    fetchAirtableData(AIRTABLE_CONFIG.SCENES_TABLE_ID, sceneFilter),
                    fetchAirtableData(AIRTABLE_CONFIG.POLLS_TABLE_ID, pollFilter),
                    fetchAirtableData(AIRTABLE_CONFIG.POLLS_TABLE_ID, `AND({ActionType}='Action')`)
                ]);
                if (!sceneData.length) throw new Error(`Scene with SceneID "${sceneID}" not found.`);
                // If this is an action poll, use all unlocked action choices, else use mapped choices
                let pollChoices = pollChoicesData;
                const sceneFields = sceneData[0].fields;
                if (
                    pollChoicesData.length > 0 &&
                    pollChoicesData[0].fields.ActionType &&
                    pollChoicesData[0].fields.ActionType.toLowerCase() === "action"
                ) {
                    pollChoices = allActionChoices;
                }
                sceneDataCache[index] = { sceneData: sceneData[0], pollChoicesData: pollChoices };
                return { sceneData: sceneData[0], pollChoicesData: pollChoices };
            } catch (error) {
                console.error(`Error fetching scene and poll data for SceneID "${sceneID}":`, error);
                throw error;
            }
        }

        async function fetchAirtableData(tableName, filterFormula = "") {
            const { BASE_ID, API_TOKEN } = AIRTABLE_CONFIG;
            const headers = { Authorization: `Bearer ${API_TOKEN}` };
            let url = `https://api.airtable.com/v0/${BASE_ID}/${tableName}`;
            if (filterFormula) {
                url += `?filterByFormula=${encodeURIComponent(filterFormula)}`;
            }

            try {
                const response = await fetch(url, { headers });
                if (!response.ok) throw new Error(`Failed to fetch data from ${tableName}: ${response.statusText}`);
                const data = await response.json();
                return data.records || [];
            } catch (error) {
                console.error(`Error fetching data from Airtable table "${tableName}":`, error);
                throw error;
            }
        }

        function renderMedia(sceneFields) {
            const widget = sceneFields.WidgetType ? sceneFields.WidgetType.toLowerCase() : "";
            if (widget === "video" && sceneFields.VideoURL) {
                let videoUrl = "";
                console.log("DEBUG VideoURL raw:", sceneFields.VideoURL);
                if (Array.isArray(sceneFields.VideoURL)) {
                    videoUrl = sceneFields.VideoURL[0]?.url || "";
                } else {
                    videoUrl = sceneFields.VideoURL;
                }
                console.log("DEBUG extracted videoUrl:", videoUrl);
                if (!videoUrl) return "";
                // CHANGED CODE: Remove muted and add onloadedmetadata to set volume = 1.
                return `
                    <div class="card-background-media">
                        <video autoplay loop playsinline onloadedmetadata="this.volume=1">
                            <source src="${videoUrl}" type="video/mp4">
                            Your browser does not support the video tag.
                        </video>
                    </div>`;
            } else if (widget === "image" && sceneFields.ImageURL) {
                let imageUrl = "";
                console.log("DEBUG ImageURL raw:", sceneFields.ImageURL);
                if (Array.isArray(sceneFields.ImageURL)) {
                    imageUrl = sceneFields.ImageURL[0]?.url || "";
                } else {
                    imageUrl = sceneFields.ImageURL;
                }
                console.log("DEBUG extracted imageUrl:", imageUrl);
                if (!imageUrl) return "";
                return `
                    <div class="card-background-media">
                        <img src="${imageUrl}" alt="${sceneFields.Title || 'Scene Media'}">
                    </div>`;
            } else if (widget === "graph" && sceneFields.GraphData) {
                return `
                    <div class="card-background-media">
                        <canvas id="graphCanvas"></canvas>
                    </div>`;
            }
            return "";
        }

        function updateNavButtons() {
            const prevButton = document.getElementById("prevButton");
            const nextButton = document.getElementById("nextButton");
            prevButton.disabled = currentSceneIndex === 0;
            nextButton.disabled = currentSceneIndex >= totalScenes - 1;
        }

        // ADD: New helper function "renderHeader" before its first use in renderScene
        function renderHeader(sceneFields) {
            // Assume timelineData and gameStartTime are defined globally
            const currentAct = (sceneFields.Act !== undefined) ? sceneFields.Act + 1 : 'N/A';
            const totalActs = (timelineData && timelineData.totalActs) || 'N/A';
            const elapsedTime = gameStartTime ? Math.floor((Date.now() - gameStartTime) / 60000) : 0;
            return `<div class="timeline-header">
                        <strong>Scene ${sceneFields.SceneID || 'N/A'} - Act ${currentAct}/${totalActs}</strong> | 
                        Game Time: ${sceneFields.GameDateTime || 'N/A'} | 
                        Elapsed: ${elapsedTime} min
                    </div>`;
        }

        // ADD: New function to update currentTeam from Airtable Teams table
        async function updateTeamFromAirtable() {
            if (!currentTeam || !currentTeam.name) {
                console.warn("No currentTeam name. Cannot update team from Airtable.");
                return;
            }
            const { BASE_ID, TEAMS_TABLE_ID, API_TOKEN } = AIRTABLE_CONFIG;
            const headers = { Authorization: `Bearer ${API_TOKEN}` };
            const filter = encodeURIComponent(`{Name}='${currentTeam.name}'`);
            const urlGet = `https://api.airtable.com/v0/${BASE_ID}/${TEAMS_TABLE_ID}?filterByFormula=${filter}`;
            try {
                const getResponse = await fetch(urlGet, { headers });
                const getData = await getResponse.json();
                if (getData.records && getData.records.length > 0) {
                    const latestTeam = getData.records[0].fields;
                    // Update currentTeam solely based on Airtable data.
                    currentTeam.capacities = latestTeam.capacities;
                    currentTeam.finances = latestTeam.finances;
                    currentTeam.socialCapital = latestTeam.socialCapital;
                    console.log("Updated currentTeam from Airtable:", currentTeam);
                } else {
                    console.warn("No team record found for", currentTeam.name);
                }
            } catch (error) {
                console.error("Error in updateTeamFromAirtable:", error);
            }
        }

        // UPDATED updateTeamHeader: remove duplicate extra header (renderTeamResources)
        async function updateTeamHeader() {
            await updateTeamFromAirtable();
            const headerContainer = document.querySelector('.media-header-area');
            if (headerContainer && sceneDataCache[currentSceneIndex] && sceneDataCache[currentSceneIndex].sceneData.fields) {
                // Find the team-info element and update it, leaving the header and chart intact.
                const teamInfoEl = headerContainer.querySelector('.team-info');
                if (teamInfoEl) {
                    teamInfoEl.outerHTML = renderTeamInfo();
                }
            } else {
                console.warn("updateTeamHeader: Header container or scene fields not available.");
            }
        }

        // NEW: Async helper to process dynamic placeholders of the form {From TableName, FieldName}
        async function processDynamicPlaceholders(content) {
            if (!content) return content;
            const pattern = /{From\s*([^,}]+)\s*,\s*([^}]+)}/g;
            let match;
            while ((match = pattern.exec(content)) !== null) {
                const fullMatch = match[0];
                const tableName = match[1].trim();
                const fieldName = match[2].trim();
                try {
                    const records = await fetchAirtableData(tableName);
                    let replacement = "";
                    if (records && records.length > 0) {
                        replacement = records[0].fields[fieldName] || "";
                    }
                    content = content.replace(fullMatch, replacement);
                } catch (err) {
                    console.error(`Error processing placeholder ${fullMatch}:`, err);
                    content = content.replace(fullMatch, "");
                }
            }
            return content;
        }

        // NEW: Process team-related placeholders (e.g. {NAME}, {Testing Capacity}, etc.)
        function processTeamPlaceholders(content) {
            if (!content || !currentTeam) return content;
            const mappings = {
                "NAME": currentTeam.name || "",
                "TESTING CAPACITY": currentTeam.capacities?.testingCapacity || "0",
                "SCIENCE CAPACITY": currentTeam.capacities?.scienceCapacity || "0",
                "HUMAN HEALTHCARE CAPACITY": currentTeam.capacities?.publicHealthCapacity || "0",
                "DEVELOPMENT CAPACITY": currentTeam.capacities?.developmentCapacity || "0",
                "SYSTEM FINANCES": currentTeam.finances?.system || "0",
                "SOCIAL CAPITAL": currentTeam.socialCapital || "0"
            };
            // Replace each instance of {token} (ignoring tokens starting with "FROM ")
            content = content.replace(/{\s*([^}]+)\s*}/g, (match, token) => {
                const key = token.trim().toUpperCase();
                if (key.startsWith("FROM ")) {
                    return "";
                }
                return mappings[key] !== undefined ? mappings[key] : "";
            });
            return content;
        }

        // UPDATED updatePlaceholders: first process dynamic {From Table, Field} placeholders, then team tokens.
        async function updatePlaceholders(content) {
            if (!content) return content;
            content = await processDynamicPlaceholders(content);
            content = processTeamPlaceholders(content);
            return content;
        }

        // NEW: Function to write the currentTeam record back to Airtable
        async function writeTeamToAirtable() {
            if (!currentTeam || !currentTeam.name) {
                console.warn("No currentTeam data available for update.");
                return;
            }
            const { BASE_ID, TEAMS_TABLE_ID, API_TOKEN } = AIRTABLE_CONFIG;
            const headers = {
                "Authorization": `Bearer ${API_TOKEN}`,
                "Content-Type": "application/json"
            };
            // First, fetch the record ID for the team matching currentTeam.name.
            const filter = encodeURIComponent(`{Name}='${currentTeam.name}'`);
            const urlGet = `https://api.airtable.com/v0/${BASE_ID}/${TEAMS_TABLE_ID}?filterByFormula=${filter}`;
            try {
                const getResponse = await fetch(urlGet, { headers });
                const getData = await getResponse.json();
                if (getData.records && getData.records.length > 0) {
                    const recordId = getData.records[0].id;
                    // CHANGED CODE: Correct the URL interpolation for the PATCH request.
                    const urlPatch = `https://api.airtable.com/v0/${BASE_ID}/${TEAMS_TABLE_ID}/${recordId}`;
                    const body = JSON.stringify({
                        fields: {
                            capacities: currentTeam.capacities,
                            finances: currentTeam.finances,
                            socialCapital: currentTeam.socialCapital
                        }
                    });
                    const patchResponse = await fetch(urlPatch, {
                        method: "PATCH",
                        headers,
                        body
                    });
                    if (!patchResponse.ok) {
                        console.error("Error updating team in Airtable:", patchResponse.statusText);
                    } else {
                        console.log("Team update written to Airtable successfully.");
                    }
                } else {
                    console.warn("No matching team record found in Airtable for", currentTeam.name);
                }
            } catch (error) {
                console.error("Error in writeToAirtable:", error);
            }
        }

        // ADD new helper for dynamic team profile card
        async function renderTeamProfileCard() {
            const cardText = `Your team {from Teams} has been assigned to manage the response for Region {NAME}. Familiarize yourselves with your region's starting profile:
Testing Capacity: {Testing Capacity}
Science Capacity: {Science Capacity}
Human Healthcare Capacity: {Human Healthcare Capacity}
Development Capacity: {Development Capacity}
System Finances: {System Finances}M
Social Capital: {Social Capital}
These values represent relative strengths and weaknesses. Consider how these factors impact your ability to handle simultaneous human and animal health threats. Your regional profile is displayed below the timeline header.`;
            return await updatePlaceholders(cardText);
        }

        // Helper to get unique categories from poll choices
        function getActionPollCategories(pollChoicesData) {
            const categories = [];
            pollChoicesData.forEach(choice => {
                if (evaluateCondition(choice.fields.ConditionLogic)) {
                    const cat = choice.fields.Category || "Uncategorized";
                    if (!categories.includes(cat)) categories.push(cat);
                }
            });
            return categories;
        }

        // Helper to render category nav
        function renderActionCategoryNav(categories) {
            return `
                <div class="poll-category-nav">
                    ${categories.map(cat => `
                        <span class="poll-category-tab${selectedActionCategory === cat ? " selected" : ""}" 
                              onclick="selectActionCategory('${cat.replace(/'/g, "\\'")}')">${cat}</span>
                    `).join("")}
                </div>
            `;
        }

        // Expose category selector to window
        window.selectActionCategory = function(cat) {
            selectedActionCategory = cat;
            // Re-render only the poll cards area
            const pollCardsArea = document.getElementById("actionPollCardsArea");
            if (pollCardsArea && window.currentActionPollChoices) {
                pollCardsArea.innerHTML = renderActionPollCards(window.currentActionPollChoices, cat);
            }
        };

        // Add search bar rendering to action poll UI
        function renderActionPollSearchBar() {
            return `
                <div class="poll-search-bar-container">
                    <input
                        type="text"
                        class="poll-search-bar"
                        id="actionPollSearchBar"
                        placeholder="Search actions..."
                        value="${actionPollSearchTerm.replace(/"/g, "&quot;")}"
                        oninput="window.onActionPollSearchInput(this.value)"
                        autocomplete="off"
                    />
                </div>
            `;
        }

        // Expose search handler
        window.onActionPollSearchInput = function(val) {
            actionPollSearchTerm = val;
            const pollCardsArea = document.getElementById("actionPollCardsArea");
            if (pollCardsArea && window.currentActionPollChoices) {
                pollCardsArea.innerHTML = renderActionPollCards(window.currentActionPollChoices, selectedActionCategory);
            }
        };

        // Helper to render action poll cards for a category
        function renderActionPollCards(pollChoicesData, category) {
            let filtered = pollChoicesData.filter(choice =>
                evaluateCondition(choice.fields.ConditionLogic) &&
                (choice.fields.Category || "Uncategorized") === category
            );
            if (actionPollSearchTerm && actionPollSearchTerm.trim() !== "") {
                const term = actionPollSearchTerm.trim().toLowerCase();
                filtered = filtered.filter(choice =>
                    (choice.fields.ChoiceText || "").toLowerCase().includes(term)
                );
            }
            if (filtered.length === 0) {
                return `<div class="poll-no-choices">No options in this category.</div>`;
            }
            return `
                <div class="poll-cards-grid">
                    ${filtered.map(choice => {
                        const choiceText = choice.fields.ChoiceText || "Choice text missing";
                        const cost = choice.fields.Cost || "N/A";
                        const time = choice.fields.Time || "N/A";
                        const social = choice.fields.SocialCapital || "N/A";
                        return `
                            <div class="poll-card" onclick="toggleSelection(this)" data-choice-id="${choice.id}">
                                <div class="poll-text">${choiceText}</div>
                                <div class="poll-details">
                                    <span class="poll-detail">Cost: ${cost}</span>
                                    <span class="poll-detail">Time: ${time}</span>
                                    <span class="poll-detail">Social: ${social}</span>
                                </div>
                            </div>
                        `;
                    }).join("")}
                </div>
            `;
        }

        // ========================================================================
        // == 3. CORE RENDERING FUNCTIONS ==
        // ========================================================================
        async function renderScene() {
            const container = document.getElementById("sceneContainer");
            container.innerHTML = `<div style="padding: 40px; text-align: center;">Loading Scene ${currentSceneIndex}...</div>`;
            try {
                // ...existing code to load scene data...
                if (!sceneDataCache[currentSceneIndex]) {
                    console.log(`Cache miss for scene ${currentSceneIndex}, fetching...`);
                    sceneDataCache[currentSceneIndex] = await fetchSceneAndChoiceData(currentSceneIndex);
                }
                const cache = sceneDataCache[currentSceneIndex];
                if (!cache || !cache.sceneData) {
                    throw new Error(`Scene data missing for scene ${currentSceneIndex}.`);
                }
                const scene = cache.sceneData.fields;
                const processedSceneTitle = await updatePlaceholders(scene.Title || "Untitled Scene");
                const processedSceneContent = await updatePlaceholders(scene.Content || "No content available.");
                const headerHtml = renderHeader(scene);

                let pollHtml = "", chartHtml = "", sunburstHtml = "";
                if (cache.pollChoicesData && cache.pollChoicesData.length > 0) {
                    pollHtml = `<div class="poll-area">
                                  <div class="poll-stem">
                                      ${scene.PollStem ? `<strong>${scene.PollStem}</strong>` : "<strong>Please select an option:</strong>"}
                                  </div>
                                  ${renderPollOptions(cache.pollChoicesData)}
                               </div>`;
                }
                if ((scene.WidgetType || "").toLowerCase() === "chart") {
                    chartHtml = `<div class="outcome-card">
                                   <div class="outcome-graph">
                                      <canvas id="chartCanvas0"></canvas>
                                   </div>
                                 </div>`;
                }
                if ((scene.WidgetType || "").toLowerCase() === "sunburst") {
                    sunburstHtml = `<div class="sunburst-chart">
                                       <div id="sunburstChart" style="width: 100%; height: 400px;"></div>
                                     </div>`;
                    setTimeout(() => renderSunburstChart(), 500);
                }
                // Only include the interactive overlay if poll or chart content exists.
                let interactiveOverlayHtml = "";
                if (chartHtml || pollHtml) {
                    interactiveOverlayHtml = `<div class="interactive-overlay">
                                                  <div class="card-dynamic">
                                                      ${chartHtml || pollHtml}
                                                  </div>
                                              </div>`;
                }
                container.innerHTML = `
                    ${renderMedia(scene)}
                    <div class="media-header-area" style="padding-bottom: 10px;">
                        ${headerHtml}
                    </div>
                    ${interactiveOverlayHtml}
                    <div class="narrative-overlay" style="padding-top: 10px;">
                        <div class="scene-title">${processedSceneTitle}</div>
                        <div class="scene-content">${processedSceneContent}</div>
                        ${sunburstHtml || ""}
                    </div>
                `;
                updateNavButtons();
                if (scene.TimerSeconds && scene.TimerSeconds > 0) {
                    initializeTimer(scene.TimerSeconds);
                }
                await updateTeamHeader();
                if ((scene.WidgetType || "").toLowerCase() === "chart") {
                    const chartData = generatePlaceholderChartData(cache.sceneData);
                    try {
                        renderChart(cache.sceneData, 0, chartData);
                    } catch (chartError) {
                        console.error("Error rendering chart:", chartError);
                    }
                }
            } catch (error) {
                container.innerHTML = `<p style="color:red;">Error loading scene ${currentSceneIndex}: ${error.message}</p>`;
            }
        }

        async function submitPoll(event) {
            if (event) event.preventDefault();
            if (pollSubmitted) return; // Prevent duplicate submissions
            pollSubmitted = true;
            clearInterval(window.countdownInterval);  // Ensure timer is cleared
            const form = document.getElementById("pollForm");
            const submitButton = document.querySelector('.poll-submit');
            if (submitButton) {
                submitButton.disabled = true;
                submitButton.innerText = "Processing...";
            }
            let selectedChoiceIDs = [];
            if (form && form.elements["pollChoice"]) {
                let pollElems = form.elements["pollChoice"];
                if (!pollElems.length) { 
                    pollElems = [pollElems];
                } else {
                    pollElems = Array.from(pollElems);
                }
                pollElems.forEach(radio => {
                    if (radio.checked) {
                        selectedChoiceIDs.push(radio.value);
                    }
                });
            }
            if (selectedChoiceIDs.length === 0) {
                console.log("No poll option selected, advancing scene.");
                setTimeout(() => nextScene(), 100); // Added delay to help UI settle
                pollSubmitted = false;
                return;
            }
            console.log("Submit Response clicked. Selected IDs:", selectedChoiceIDs);
            const currentSceneFullData = sceneDataCache[currentSceneIndex];
            if (!currentSceneFullData || !currentSceneFullData.pollChoicesData) {
                console.error("Cannot process poll: Missing cached scene/poll data.");
                if (submitButton) submitButton.innerText = "Error";
                pollSubmitted = false;
                return;
            }
            const choiceDataLookup = {};
            currentSceneFullData.pollChoicesData.forEach(choice => {
                choiceDataLookup[choice.id] = choice;
            });
            try {
                for (const choiceID of selectedChoiceIDs) {
                    const choiceData = choiceDataLookup[choiceID];
                    if (!choiceData) {
                        console.error("Invalid choice ID submitted:", choiceID);
                        throw new Error("Invalid poll option selected.");
                    }
                    if (!evaluateCondition(choiceData.fields.ConditionLogic)) {
                        console.error(`The selected option "${choiceData.fields.ChoiceText}" is no longer valid.`);
                        throw new Error("Poll option no longer valid.");
                    }
                    await processPollSubmission(choiceData, currentSceneFullData.sceneData.fields.PollID);
                }
                if (submitButton) {
                    submitButton.innerText = "Response Submitted";
                }
                console.log("Poll submission complete. Advancing scene.");
                setTimeout(() => nextScene(), 100);
            } catch (error) {
                console.error("Error during poll submission:", error);
                if (submitButton) {
                    submitButton.innerText = "Error";
                }
                // Advance scene even if an error occurs
                setTimeout(() => nextScene(), 100);
            } finally {
                pollSubmitted = false;
            }
        }

        // New helper function to process individual poll submissions based on target table.
        async function processPollSubmission(choiceRecord, pollID) {
            const modelParameter = choiceRecord.fields.ModelParameter;
            const operator = choiceRecord.fields.Operator; // e.g. "+" or "-" (if provided)
            if (modelParameter) {
                const parts = modelParameter.split(".");
                if (parts.length >= 2) {
                    const tableName = parts[0].trim().toLowerCase();
                    const fieldName = parts.slice(1).join(".").trim();
                    if (tableName === "teams") {
                        // Mapping for Teams fields update
                        const teamFieldMapping = {
                            "System Finance": { container: "finances", key: "system" },
                            "Social Capital": { container: "socialCapital" },
                            "Human Healthcare Capacity": { container: "capacities", key: "publicHealthCapacity" },
                            "Testing Capacity": { container: "capacities", key: "testingCapacity" },
                            "Science Capacity": { container: "capacities", key: "scienceCapacity" },
                            "Animal Surveillance Capacity": { container: "capacities", key: "animalSurveillanceCapacity" }
                        };
                        const mapping = teamFieldMapping[fieldName];
                        if (mapping) {
                            let inc = parseInt(choiceRecord.fields.UpdateIncrement || "1", 10);
                            if (operator && operator.trim() === "-") {
                                inc = -inc;
                            }
                            if (mapping.container === "finances") {
                                currentTeam.finances[mapping.key] = (parseInt(currentTeam.finances[mapping.key] || "0", 10) + inc);
                            } else if (mapping.container === "capacities") {
                                currentTeam.capacities[mapping.key] = (parseInt(currentTeam.capacities[mapping.key] || "0", 10) + inc);
                            } else if (mapping.container === "socialCapital") {
                                currentTeam.socialCapital = (parseInt(currentTeam.socialCapital || "0", 10) + inc);
                            }
                            await updatePollResponses([choiceRecord.id], pollID);
                            await writeTeamToAirtable();
                        } else {
                            console.error("Mapping not found for field:", fieldName);
                            await updatePollResponses([choiceRecord.id], pollID);
                        }
                    } else if (tableName === "configgame") {
                        let inc = parseInt(choiceRecord.fields.UpdateIncrement || "1", 10);
                        if (operator && operator.trim() === "-") {
                            inc = -inc;
                        }
                        await writeToGameConfig(fieldName, inc);
                        await updatePollResponses([choiceRecord.id], pollID);
                    } else {
                        await updatePollResponses([choiceRecord.id], pollID);
                    }
                } else {
                    await updatePollResponses([choiceRecord.id], pollID);
                }
            } else {
                await updatePollResponses([choiceRecord.id], pollID);
            }
        }

        // NEW: Helper to update GameConfig table
        async function writeToGameConfig(fieldName, increment) {
            const { BASE_ID, CONFIG_GAME_TABLE_ID, API_TOKEN } = AIRTABLE_CONFIG;
            const headers = { Authorization: `Bearer ${API_TOKEN}`, "Content-Type": "application/json" };
            try {
                // Find GameConfig record for the current team using a filter on the 'Team' field
                const filter = encodeURIComponent(`{Team}='${currentTeam.name}'`);
                const urlGet = `https://api.airtable.com/v0/${BASE_ID}/${CONFIG_GAME_TABLE_ID}?filterByFormula=${filter}`;
                const response = await fetch(urlGet, { headers });
                if (!response.ok) throw new Error(`Failed to fetch GameConfig data: ${response.statusText}`);
                const data = await response.json();
                if (data.records && data.records.length > 0) {
                    const recordId = data.records[0].id;
                    const currentVal = parseInt(data.records[0].fields[fieldName] || "0", 10);
                    const newVal = currentVal + increment;
                    const body = JSON.stringify({
                        fields: { [fieldName]: newVal }
                    });
                    const urlPatch = `https://api.airtable.com/v0/${BASE_ID}/${CONFIG_GAME_TABLE_ID}/${recordId}`;
                    const patchResponse = await fetch(urlPatch, { method: "PATCH", headers, body });
                    if (!patchResponse.ok) {
                        console.error("Error updating GameConfig for", fieldName, patchResponse.statusText);
                    } else {
                        console.log("GameConfig updated successfully for", fieldName, newVal);
                    }
                } else {
                    console.warn("No GameConfig record found for team", currentTeam.name);
                }
            } catch (error) {
                console.error("Error in writeToGameConfig:", error);
            }
        }

        async function updatePollResponses(selectedChoiceIDs, pollID) {
            const { BASE_ID, POLL_RESPONSES_TABLE_ID, API_TOKEN } = AIRTABLE_CONFIG;
            const headers = { Authorization: `Bearer ${API_TOKEN}`, "Content-Type": "application/json" };
            const payload = {
                records: selectedChoiceIDs.map(choiceId => ({
                    fields: {
                        PollID: pollID,
                        ChoiceID: choiceId,
                        TeamID: currentTeam.name,
                        ResponseCount: 1
                    }
                }))
            };
            console.log("Sending PollResponses payload:", JSON.stringify(payload));
            const url = `https://api.airtable.com/v0/${BASE_ID}/${POLL_RESPONSES_TABLE_ID}`;
            const response = await fetch(url, { method: "POST", headers, body: JSON.stringify(payload) });
            if (!response.ok) {
                const text = await response.text();
                console.error("Error updating PollResponses:", text);
                throw new Error(`Failed to update PollResponses: ${response.statusText}`);
            }
            const data = await response.json();
            console.log("PollResponses updated successfully:", data);
        }

        async function writeToAirtable(tableName, parameter, value) {
            const { BASE_ID, API_TOKEN } = AIRTABLE_CONFIG;
            const headers = { Authorization: `Bearer ${API_TOKEN}`, "Content-Type": "application/json" };
            const record = {
                fields: {
                    Parameter: parameter,
                    Value: value,
                    TeamID: currentTeam.name
                }
            };
            console.log(`Writing to ${tableName} with payload:`, JSON.stringify({ records: [record] }));
            const url = `https://api.airtable.com/v0/${BASE_ID}/${tableName}`;
            try {
                const response = await fetch(url, {
                    method: "POST",
                    headers,
                    body: JSON.stringify({ records: [record] })
                });
                const text = await response.text();
                console.log(`Raw response from ${tableName} POST:`, text);
                if (!response.ok) {
                    console.error(`Error writing to ${tableName}:`, text);
                    throw new Error(`Failed to write to ${tableName}: ${response.status} ${response.statusText}`);
                }
                console.log(`Successfully wrote to ${tableName}:`, parameter, value);
            } catch (error) {
                console.error(`Error writing to ${tableName}:`, error);
                throw error;
            }
        }

        async function nextScene() {
            if (currentSceneIndex < totalScenes - 1) {
                currentSceneIndex++;
                await renderScene();
            }
        }

        async function prevScene() {
            if (currentSceneIndex > 0) {
                currentSceneIndex--;
                await renderScene();
            }
        }

        // ========================================================================
        // == 4. INITIALIZATION ==
        // ========================================================================
        async function fetchInitialSceneList() {
            const { BASE_ID, SCENES_TABLE_ID, API_TOKEN } = AIRTABLE_CONFIG;
            const headers = { Authorization: `Bearer ${API_TOKEN}` };
            const url = `https://api.airtable.com/v0/${BASE_ID}/${SCENES_TABLE_ID}`;
            try {
                const response = await fetch(url, { headers });
                const data = await response.json();
                // Only keep records with a valid SceneID (not Scene_ID)
                sceneList = (data.records || [])
                    .filter(r => r.fields && typeof r.fields.SceneID !== "undefined" && String(r.fields.SceneID).trim() !== "");
                if (sceneList.length === 0) {
                    totalScenes = 0;
                    throw new Error("No scenes with a valid SceneID found in Airtable.");
                }
                // Natural sort by SceneID (alphanumeric, numbers sorted numerically)
                sceneList.sort((a, b) => {
                    const aID = String(a.fields.SceneID);
                    const bID = String(b.fields.SceneID);
                    return aID.localeCompare(bID, undefined, { numeric: true, sensitivity: 'base' });
                });
                totalScenes = sceneList.length;
            } catch (error) {
                console.error("Error fetching scene list:", error);
                sceneList = [];
                totalScenes = 0;
                throw error;
            }
        }

        async function initializeGame() {
            console.log("Initializing Game...");
            gameStartTime = Date.now(); // Set game start time
            try {
                await fetchInitialSceneList();
                if (sceneList.length === 0) {
                    document.getElementById("sceneContainer").innerHTML = `<p style="color:red;">No scenes found in Airtable. Please check your data.</p>`;
                    return;
                }
            } catch (err) {
                console.error("Scene list error. Using default totalScenes.");
                totalScenes = 40;
                document.getElementById("sceneContainer").innerHTML = `<p style="color:red;">Error loading scenes: ${err.message}</p>`;
                return;
            }
            await renderScene();
        }
        document.addEventListener("DOMContentLoaded", initializeGame);

        // ADD: Missing initializeTimer function
        function initializeTimer(durationSeconds) {
            const container = document.getElementById("sceneContainer");
            if (!container) {
                console.error("Scene container not found!");
                return;
            }
            // Create or update the round timer element
            let timerEl = document.getElementById("timerDisplay");
            if (!timerEl) {
                timerEl = document.createElement("div");
                timerEl.id = "timerDisplay";
                timerEl.style.position = "absolute";
                timerEl.style.top = "10px";          // at the top
                timerEl.style.right = "10px";        // at the right
                timerEl.style.width = "50px";        // round shape dimensions
                timerEl.style.height = "50px";       // round shape dimensions
                timerEl.style.borderRadius = "50%";     // round shape dimensions
                timerEl.style.backgroundColor = "#161b22";
                timerEl.style.color = "#f0f6fc";
                timerEl.style.display = "flex";
                timerEl.style.alignItems = "center";
                timerEl.style.justifyContent = "center";
                timerEl.style.fontSize = "0.75em";
                timerEl.style.fontWeight = "bold";
                timerEl.style.zIndex = "20";
                container.appendChild(timerEl);
            }
            clearInterval(window.countdownInterval);
            let timeLeft = durationSeconds;
            updateTimerDisplay(timerEl, timeLeft);
            window.countdownInterval = setInterval(async () => {
                timeLeft--;
                if (timeLeft >= 0) {
                    updateTimerDisplay(timerEl, timeLeft);
                } else {
                    clearInterval(window.countdownInterval);
                    if (!pollSubmitted) {
                        await submitPoll();
                    }
                }
            }, 1000);
        }

        // ADD: Helper to update timer display
        function updateTimerDisplay(timerEl, timeLeft) {
            const minutes = Math.floor(timeLeft / 60);
            const seconds = (timeLeft % 60).toString().padStart(2, "0");
            // Only display the MM:SS without extra text
            timerEl.innerText = `${minutes}:${seconds}`;
        }

        function renderTeamInfo() {
            console.log("renderTeamInfo called. CurrentTeam:", JSON.stringify(currentTeam));
            if (!currentTeam) return '<div class="team-info">Error loading team data</div>';
            const caps = currentTeam.capacities || {};
            const fins = currentTeam.finances || {};
            const socialCap = currentTeam.socialCapital !== undefined ? currentTeam.socialCapital : 'N/A';
            // Updated to display actual capacity values
            return `<div class="team-info">
                <strong>Team:</strong> ${currentTeam.name || 'N/A'} | 
                <strong>Testing Capacity:</strong> ${caps.testingCapacity || 0} | 
                <strong>Science Capacity:</strong> ${caps.scienceCapacity || 0} | 
                <strong>Public Health Capacity:</strong> ${caps.publicHealthCapacity || 0} | 
                <strong>Development Capacity:</strong> ${caps.developmentCapacity || 0} | 
                <strong>System Finances:</strong> ${fins.system || 0}M | 
                <strong>Social Capital:</strong> ${socialCap}
            </div>`;
        }

        // Updated renderTeamResources function to dynamically insert region name and parameter values
        function renderTeamResources() {
            if (!currentTeam) return "<p>Team data not available.</p>";
            const caps = currentTeam.capacities || {};
            const fins = currentTeam.finances || {};
            const social = currentTeam.socialCapital ?? "N/A";
            return `
                <div class="team-info">
                    Your team has been assigned to manage the response for <strong>Region ${currentTeam.name}</strong>.
                    Familiarize yourselves with your region's starting profile:
                    <ul>
                        <li>Testing Capacity: ${caps.testingCapacity || 0}</li>
                        <li>Science Capacity: ${caps.scienceCapacity || 0}</li>
                        <li>Human Healthcare Capacity: ${caps.publicHealthCapacity || 0}</li>
                        <li>Development Capacity: ${caps.developmentCapacity || 0}</li>
                        <li>System Finances: ${fins.system || 0}M</li>
                        <li>Social Capital: ${social}</li>
                    </ul>
                </div>
            `;
        }

        // Add missing generatePlaceholderChartData() helper
        function generatePlaceholderChartData(sceneData) {
            if (!sceneData || !sceneData.fields) {
                return null;
            }
            const scene = sceneData.fields;
            let rawType = scene.ChartType;
            let chartType = "bar";
            if (typeof rawType === "string" && rawType.trim().toLowerCase() !== "false" && rawType.trim() !== "") {
                 chartType = rawType.trim().toLowerCase();
            }
            // Force chartType to "bar" if it is "sunburst"
            if (chartType === "sunburst") {
                 chartType = "bar";
            }
            let chartData;
            if (chartType === "line") {
                chartData = {
                    labels: ["Start", "Act 1", "Act 2", "Act 3", "Now"],
                    datasets: [{
                        label: scene.Title || "Line Chart",
                        data: [10, 20, 30, 40, 50],
                        borderColor: "#58a6ff",
                        fill: false
                    }],
                };
            } else if (chartType === "pie") {
                chartData = {
                    labels: ["A", "B", "C", "D"],
                    datasets: [{
                        data: [25, 25, 25, 25],
                        backgroundColor: ["#2ea043", "#58a6ff", "#db617e", "#a371f7"]
                    }],
                };
            } else {
                chartData = {
                    labels: ["X", "Y", "Z"],
                    datasets: [{
                        label: scene.Title || "Bar Chart",
                        data: [5, 15, 10],
                        backgroundColor: "#58a6ff"
                    }],
                };
            }
            return { type: chartType, data: chartData, title: scene.Title || "Chart" };
        }

        function renderChart(sceneData, canvasIndex, chartDataSource = null) {
            const canvasId = `chartCanvas${canvasIndex}`;
            const canvasElement = document.getElementById(canvasId);
            if (!canvasElement) {
                console.error(`Canvas element ${canvasId} not found.`);
                return;
            }
            const ctx = canvasElement.getContext("2d");
            let chartInfo = chartDataSource;
            if (!chartInfo) {
                console.warn("No chart data source, generating placeholder for scene:", sceneData?.fields?.SceneID);
                chartInfo = generatePlaceholderChartData(sceneData);
            }
            if (!chartInfo || !chartInfo.data) {
                console.error("No valid chart data for scene:", sceneData?.fields?.SceneID);
                canvasElement.parentElement.innerHTML = "<p style='color: orange;'>Chart data not available.</p>";
                return;
            }
            const chartType = chartInfo.type || "bar";
            const chartData = chartInfo.data;
            const options = {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: true,
                        labels: { color: "#c9d1d9" }
                    },
                    title: {
                        display: true,
                        text: chartInfo.title || "Chart",
                        color: "#f0f6fc",
                        font: { size: 16 }
                    }
                },
                scales: {
                    x: {
                        ticks: { color: "#8b949e" },
                        grid: { color: "#30363d" }
                    },
                    y: {
                        ticks: { color: "#8b949e" },
                        grid: { color: "#30363d" }
                    }
                }
            };
            if (chartType === "pie") {
                delete options.scales;
            }
            if (canvasIndex === 0 && window.currentChart) {
                window.currentChart.destroy();
            }
            const newChart = new Chart(ctx, { type: chartType, data: chartData, options: options });
            if (canvasIndex === 0) {
                window.currentChart = newChart;
            }
        };

        async function renderSunburstChart() {
            const { BASE_ID, TEAMS_TABLE_ID, API_TOKEN } = AIRTABLE_CONFIG;
            const headers = { Authorization: `Bearer ${API_TOKEN}` };
            const url = `https://api.airtable.com/v0/${BASE_ID}/${TEAMS_TABLE_ID}`;
            try {
                const response = await fetch(url, { headers });
                if (!response.ok) throw new Error(`Failed to fetch Teams data: ${response.statusText}`);
                const data = await response.json();
                // Process data for the sunburst chart
                const labels = [];
                const parents = [];
                const values = [];
                data.records.forEach(record => {
                    const fields = record.fields;
                    labels.push(fields.Name || "Unknown");
                    parents.push(""); // Root level
                    values.push(fields.Capacities?.testingCapacity || 0); // Example: testingCapacity
                });

                const chartData = [{
                    type: "sunburst",
                    labels: labels,
                    parents: parents,
                    values: values,
                    branchvalues: "total",
                    textinfo: "label+value+percent entry",
                    font: { color: "#c9d1d9" }
                }];

                const layout = {
                    margin: { t: 10, l: 10, r: 10, b: 10 },
                    paper_bgcolor: "#161b22",
                    font: { color: "#c9d1d9" }
                };

                Plotly.newPlot("sunburstChart", chartData, layout);
            } catch (error) {
                console.error("Error rendering sunburst chart:", error);
                document.getElementById("sunburstChart").innerHTML = `<p style="color: red;">Error loading chart data.</p>`;
            }
        }

        // Evaluate condition using the current simulation state
        function evaluateCondition(conditionLogic) {
            if (!conditionLogic || typeof conditionLogic !== "string") return true;
            try {
                // Dynamically evaluate the condition using the current simulation state
                const conditionFunction = new Function(
                    "simulationState",
                    `return (${conditionLogic});`
                );
                return conditionFunction(simulationState);
            } catch (error) {
                console.error(`Error evaluating condition "${conditionLogic}":`, error);
                return false;
            }
        }

        function renderPollOptions(pollChoicesData) {
            if (
                pollChoicesData.length > 0 &&
                pollChoicesData[0].fields.ActionType &&
                pollChoicesData[0].fields.ActionType.toLowerCase() === "action"
            ) {
                // --- NEW: Action Poll Store by Category ---
                // Save for re-rendering on category change
                window.currentActionPollChoices = pollChoicesData;
                const categories = getActionPollCategories(pollChoicesData);
                // Default to first category if not set
                if (!selectedActionCategory || !categories.includes(selectedActionCategory)) {
                    selectedActionCategory = categories[0];
                }
                return `
                    <form id="pollForm">
                        ${renderActionCategoryNav(categories)}
                        ${renderActionPollSearchBar()}
                        <div id="actionPollCardsArea">
                            ${renderActionPollCards(pollChoicesData, selectedActionCategory)}
                        </div>
                        <button type="button" class="poll-finished" onclick="submitPoll(event)">Finished</button>
                    </form>
                `;
            } else {
                // Default: Render as radio buttons with "Submit Response" button.
                const pollHtml = pollChoicesData
                    .filter(choice => evaluateCondition(choice.fields.ConditionLogic))
                    .map((choice, idx) => {
                        const choiceText = choice.fields.ChoiceText || "Choice text missing";
                        return `
                            <div class="poll-option">
                                <input type="radio" id="choice${idx}" name="pollChoice" value="${choice.id}">
                                <label for="choice${idx}">${choiceText}</label>
                            </div>
                        `;
                    }).join("");
                return `<form id="pollForm">
                            ${pollHtml}
                            <button type="button" class="poll-submit" onclick="submitPoll(event)">Submit Response</button>
                        </form>`;
            }
        }

        function toggleSelection(cardEl) {
            cardEl.classList.toggle("selected");
        }
    </script>
</body>
</html>
``` 
